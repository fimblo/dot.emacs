#+TITLE:      My Emacs setup
#+AUTHOR:     Mattias Jansson (fimblo)
#+EMAIL:      fimblo@yanson.org

* Initial setup
** Set up basic environment

   Before we can go about fixing the fun parts of emacs, we'll need to
   set up some basics.

#+BEGIN_SRC emacs-lisp
(require 'cl)                 ; Get access to some more functionality
(setq message-log-max
      (- (expt 2 15) 1))      ; Make message log big
#+END_SRC

   Set some useful variables for later use

#+BEGIN_SRC emacs-lisp
(defvar home (getenv "HOME") "Home directory, sourced from Environment variable HOME")
(setq default-directory (concat home "/"))

;; If running with org-babel, the variable 'this-file' does not
;; contain the file filename.org; the file gets tangled into
;; filename.el
(setq this-file (or load-file-name (buffer-file-name)))
(setq this-file-org (replace-regexp-in-string ".el" ".org" this-file))

(defvar emacs-root
  (file-name-directory (or (file-symlink-p this-file) this-file)))

(defvar hostname (getenv "HOSTNAME") "This machine's hostname")

(setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
(setq exec-path (append exec-path '("/usr/local/bin")))

#+END_SRC

   Make _really_ sure that we're using utf-8.

#+BEGIN_SRC emacs-lisp
(setq locale-coding-system      'utf-8)
(set-terminal-coding-system     'utf-8)
(set-keyboard-coding-system     'utf-8)
(set-selection-coding-system    'utf-8)
(prefer-coding-system           'utf-8)
(set-language-environment       "UTF-8")
#+END_SRC

** Declare personal variables

   Here are the variables which are private to me, and are assigned in
   the =~/.emacs.d/.secret.el= file (which for obvious reasons aren't
   included in version control.

#+BEGIN_SRC emacs-lisp
  (defvar me/fullname              nil "My full name.")
  (defvar me/nick                  nil "My nickname.")
  (defvar me/mail/credentials      nil "Where I store my credentials.")
  (defvar me/mail/mydomain         nil "My mail domainname.")
  (defvar me/mail/smtp-server      nil "Hostname.domainname of smtp server.")
  (defvar me/mail/signature        nil "My email signature.")
  (defvar me/erc/server            nil "Irc server hostname")
  (defvar me/erc/port              nil "Irc server port")
  (defvar me/erc/nick              nil "My nick")
  (defvar me/erc/pass              nil "My password")
  (defvar me/erc/autojoin-alist    nil "Association list of channels to join.
                                        For example:
                                        ((\"chat.freenode.net\" \"#emacs\" \"#cooking\")
                                         (\"another.server.org\" \"#foo\" \"#bar\" \"#baz\"))
                                        ")
  (defvar me/erc/pass-query-string nil "How should ERC ask for the password?
                                        Useful if you have multiple servers to connect to.")

  (let ((secret.el (expand-file-name ".secret.el" user-emacs-directory)))
    (when (file-exists-p secret.el)
      (load secret.el)))

#+END_SRC
** Package.el configuration

   This needs to be in place before any configurations of installed packages.

   Most of this was shamelessly copied from @jeekl's [[https://github.com/jeekl/dotfiles/blob/master/emacs.d/emacs.org][emacs setup]]. Thanks @jeekl!

#+BEGIN_SRC emacs-lisp

;; mkdir these and add them to load path
(dolist (path '(  "~/.emacs.d/elpa/"
          "~/.emacs.d/el-get/"
          "~/.emacs.d/vendor/"))
  (make-directory path t)
  (let ((default-directory path))
    (normal-top-level-add-subdirs-to-load-path)))

(require 'package)

;; add these sources
(eval-after-load "package"
  '(progn
     (add-to-list 'package-archives '("org"       . "http://orgmode.org/elpa/"))
     (add-to-list 'package-archives '("melpa"     . "http://melpa.milkbox.net/packages/"))
     (add-to-list 'package-archives '("elpa"      . "http://elpa.gnu.org/packages/"))
     (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
     (add-to-list 'package-archives '("tromey"    . "http://tromey.com/elpa/"))
))

(setq url-http-attempt-keepalives nil)  ; A package.el bug. Apparently.
#+END_SRC

** Packages to install
#+BEGIN_SRC emacs-lisp
(defvar elpa-packages
  '(

    ;; Some themes first
    abyss-theme
    ample-theme
    arjen-grey-theme
    atom-dark-theme
    badger-theme
    birds-of-paradise-plus-theme
    color-theme
    color-theme-approximate
    color-theme-cobalt
    color-theme-twilight
    darkburn-theme
    darkmine-theme
    darkokai-theme
    darktooth-theme
    dracula-theme  
    gruvbox-theme
    poet-theme

    ;; Other packages
    adoc-mode
    apache-mode
    atomic-chrome
    column-marker
    edit-server
    gmail-message-mode
    graphviz-dot-mode
    highlight-tail
    htmlize
    json-mode
    load-theme-buffer-local
    magit
    mediawiki
    mpg123
    muttrc-mode
    olivetti
    org-bullets
    puppet-mode
    rainbow-mode
    ssh-config-mode
    twittering-mode
    yaml-mode
    )
  "These packages are installed if necessary."
  )

(if (not package-archive-contents)
    (package-refresh-contents))

(dolist (pkg elpa-packages)
  (when (and (not (package-installed-p pkg))
           (assoc pkg package-archive-contents))
    (package-install pkg)))

    
(defun package-list-unaccounted-packages ()
  "Like `package-list-packages', but shows only the packages that
  are installed and are not in `elpa-packages'.  Useful for
  cleaning out unwanted packages."
  (interactive)
  (package-show-package-list
   (remove-if-not (lambda (x) (and (not (memq x elpa-packages))
                   (not (package-built-in-p x))
                   (package-installed-p x)))
                  (mapcar 'car package-archive-contents))))

#+END_SRC

** Auto-customization

   Move all customization stuff to another file.

#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
(load custom-file 'noerror)
#+END_SRC

** Emacs server

   The emacs server is useful if you use emacs for many things, and
   you want each session to share buffers and state. Startup time is
   minimal too.

#+BEGIN_SRC emacs-lisp
(require 'server)
(load "server")
(unless (server-running-p) (server-start))
#+END_SRC
* UI
  This is the first round of setting up the UI.
** Basic look and feel

   Configuration basics.

#+BEGIN_SRC emacs-lisp
(setq default-major-mode 'org-mode)     ; default mode is org-mode

(setq fci-rule-column 80)               ; fill column
(setq inhibit-startup-message t)        ; no startup message
(setq initial-scratch-message nil)      ; no *scratch* message
(setq line-number-mode t)               ; show line number
(setq column-number-mode t)             ; show current column
(global-font-lock-mode 1)               ; syntax highlightning ON
(setq transient-mark-mode t)            ; turn on transient-mark-mode
(setq indicate-buffer-boundaries t)     ; visually show end of buffer
(setq-default indicate-empty-lines t)   ; be even more obvious about it
(setq remove-help-window t)             ; kill completion-window when
                                        ; leaving minibuffer
(setq insert-default-directory t)       ; get default dir in commands
(setq enable-local-variables t)         ; enables local variables
(setq compilation-window-height 10)     ; height of compilation window.
(setq cursor-type 'bar)                 ; make cursor thin
(tool-bar-mode -1)
(menu-bar-mode -1)
(if (boundp 'fringe-mode) (fringe-mode -1))
(if (boundp 'scroll-bar-mode) (scroll-bar-mode -1))


;; Look and feel for all programming modes
(add-hook 'prog-mode-hook
          (lambda ()
            (fringe-mode 1)
            (linum-mode 1)              ; show line number in margin
            (hl-line-mode 1)            ; highlight the current line
            (show-paren-mode t)         ; show matching parens
            )
          )




#+END_SRC

** Changes in default behaviour upon user action

   Change some basic ways in which emacs does things.

#+BEGIN_SRC emacs-lisp
(setq case-fold-search t)              ; ignore case in searches
(setq compilation-ask-about-save 0)    ; dont ask to save when compiling
(setq apropos-do-all t)                ; show all funcs/vars in help
(put 'downcase-region 'disabled nil)   ; allow downcase-region commands
(put 'upcase-region 'disabled nil)     ; allow downcase-region commands

(setq next-line-add-newlines t)        ; C-n at eob opens new lines.
(setq scroll-step 1)                   ; Moving cursor down at bottom
                                       ; scrolls only a single line
#+END_SRC

   Generally, I don't like programs asking me if I /really/ want to do
   something I just told it to do. And if it must, I want that
   interaction to be as non-intrusive as possible.

#+BEGIN_SRC emacs-lisp
(defun my-dummy-ring-bell-function () nil)    ; replace beep with visible bell
(setq ring-bell-function `my-dummy-ring-bell-function)

(fset 'yes-or-no-p 'y-or-n-p)                 ; y or n instead of yes or no
(setq confirm-nonexistent-file-or-buffer nil) ; just open new buffers
(setq kill-buffer-query-functions             ; dont ask to kill live buffers
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))
(put 'eval-expression 'disabled nil)          ; no confirm on eval-expression

#+END_SRC
** Mouse behaviour
#+BEGIN_SRC emacs-lisp
(xterm-mouse-mode t)                  ; Support mouse in xterms
(setq mouse-wheel-mode t)             ; support mouse wheel
(setq mouse-wheel-follow-mouse t)     ; scrolls mouse pointer position, not pointer
#+END_SRC
   
** Time display
#+BEGIN_SRC emacs-lisp
(display-time)
(setq display-time-day-and-date t)
(setq display-time-24hr-format t)
#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
(setq standard-indent 2)
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
(setq tab-width 4)
(setq-default tab-stop-list
              (mapcar '(lambda (x) (* x 4))
                      (cdr (reverse 
                            (let (value)
                              (dotimes (number 32 value)
                                (setq value (cons number value))))))))


(setq perl-continued-brace-offset -2)
(setq perl-continued-statement-offset 2)
(setq perl-indent-level 2)
(setq perl-label-offset -1)
(setq sh-basic-offset 2)
(setq sh-indentation 2)
#+END_SRC

** Colours, fonts and stuff

   Apparently loading a theme using (load-theme) overlays the new
   theme onto whatever was there before. This might be useful at
   times, but I find it easier when I get exactly the theme I select.

   Anyway, the advice function below makes load-theme behave the way I
   like.
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before clear-previous-themes activate)
  "Clear existing theme settings instead of layering them"
  (mapc #'disable-theme custom-enabled-themes))

(load-theme 'gruvbox)
#+END_SRC

   For the longest time, I've for some reason enjoyed writing more in
   traditional word processors like Google Docs, Openoffice, MSWord
   even if I've been an emacs user for decades. I never really
   understood why until I realised that it had to do with the UI. By
   changing the font into something with serifs, and writing in the
   "middle" of the buffer window, I discovered that writing became
   more enjoyable for me.

   The code block below toggles between prose and code mode.
   
#+BEGIN_SRC emacs-lisp

(setq f/write-state "nowrite")
(setq f/face-cookie nil)
(defun write-toggle ()
  "Toggles write-state of current buffer.

   Write-state defaults to nil, but when activated, does the following:
   - Changes the cursor to a short horizontal line
   - Changes the font to Noto Serif
   - Removes hl-line-mode
   - Activates Olivetti-mode

   Toggling again reverts the changes."

  (interactive)
  (if (string= f/write-state "write")
      (progn 
        (message "write-state")
        (setq cursor-type 'bar)
        (variable-pitch-mode 0)
        (face-remap-remove-relative f/face-cookie) ; revert to old face
        (hl-line-mode 1)
        (olivetti-mode -1)
        (setq f/write-state "nowrite"))
    (progn
      (message "not write-state")
      (setq cursor-type '(hbar . 2))
      (variable-pitch-mode 1)       
      (setq f/face-cookie              ; when changing face, save old
            (face-remap-add-relative   ; face in a cookie.
             'default 
             '(:family "Noto Serif")))
      (hl-line-mode -1)
      (olivetti-mode 1)
      (setq f/write-state "write"))))


#+END_SRC

** External stuff

   How emacs interacts with the world outside of it.
#+BEGIN_SRC emacs-lisp
; default to ssh when tramping
(setq tramp-default-method "ssh")

;; What browser to use?
(if (eq system-type 'darwin)
    (setq browse-url-browser-function 'browse-url-default-macosx-browser)
  (setq browse-url-browser-function 'browse-url-chromium)
  )

;; make scripts executable if they aren't already
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

#+END_SRC
** Map Suffixes with modes
#+BEGIN_SRC emacs-lisp
(setq auto-mode-alist
      (append
       (list
        '("\\.xml"                . xml-mode             )
        '("\\.pp"                 . puppet-mode          )
        '("\\.html"               . html-mode            )
        '("\\.xsl"                . xml-mode             )
        '("\\.cmd"                . cmd-mode             )
        '("\\.bat"                . cmd-mode             )
        '("\\.wiki"               . wikipedia-mode       )
        '("\\.org.txt"            . org-mode             )
        '("\\.txt"                . indented-text-mode   )
        '("\\.php"                . php-html-helper-mode )
        '("\\.fvwm2rc"            . shell-script-mode    )
        '("tmp/mutt-"             . message-mode         )
        '("\\.org"                . org-mode             )
        '("\\.asciidoc"           . adoc-mode            )
        '("\\.pm"                 . cperl-mode           )
        '("\\.pl"                 . cperl-mode           ))
       auto-mode-alist))

;; and ignore these suffixes when expanding
(setq completion-ignored-extensions
      '(".o" ".elc" ".class" "java~" ".ps" ".abs" ".mx" ".~jv" ))
#+END_SRC

** Display lambda symbol

   Not only is this pretty, it saves some space on the screen :)

#+BEGIN_SRC emacs-lisp
;; courtesy of stefan monnier on c.l.l
(defun sm-lambda-mode-hook ()
  (font-lock-add-keywords
   nil `(("\\<lambda\\>"
          (0 (progn (compose-region (match-beginning 0) (match-end 0)
                                    ,(make-char 'greek-iso8859-7 107))
                    nil))))))
(add-hook 'python-mode-hook 'sm-lambda-mode-hook)
(add-hook 'emacs-lisp-mode-hook 'sm-lambda-mode-hook)
(add-hook 'org-mode-hook 'sm-lambda-mode-hook)

#+END_SRC
** Other UI things
   Things don't really fit anywhere else at the moment.

#+BEGIN_SRC emacs-lisp
; empty right now
#+END_SRC
* Modes
** CUA-mode
   Cua-mode is normally used to make emacs act more like Windows
   (control-c to copy, etc). I use a subset so that I can use
   Cua-mode's nice rectangle functions in addition to the normal ones.

   Cua's global-mark is really cool. This is what it says in the manual:

#+begin_quote
CUA mode also has a global mark feature which allows easy moving and
copying of text between buffers. Use C-S-<SPC> to toggle the global
mark on and off. When the global mark is on, all text that you kill or
copy is automatically inserted at the global mark, and text you type
is inserted at the global mark rather than at the current position.
#+end_quote

   Really useful for copying text from one doc to another.

#+BEGIN_SRC emacs-lisp
(cua-mode t)
(setq cua-enable-cua-keys nil)               ; go with cua, but without c-x/v/c et al
(setq shift-select-mode nil)                 ; do not select text when moving with shift.
(setq cua-delete-selection nil)              ; dont kill selections on keypress
(setq cua-enable-cursor-indications t)       ; customize cursor color

(setq cua-normal-cursor-color "white")
;; if Buffer is...
;;(setq cua-normal-cursor-color "#15FF00")     ; R/W, then cursor is green
;;(setq cua-read-only-cursor-color "purple1")  ; R/O, then cursor is purple
;;(setq cua-overwrite-cursor-color "red")      ; in Overwrite mode, cursor is red
;;(setq cua-global-mark-cursor-color "yellow") ; in Global mark mode, cursor is yellow

#+END_SRC

** Org-mode
   I love org-mode, even if I only use a fraction of its capabilities.
#+BEGIN_SRC emacs-lisp
(require 'org-install)
(setq org-log-done 'time)
(setq org-directory (concat home "/notes/"))
(make-directory org-directory 1)
(setq org-default-notes-file (concat org-directory "/notes.org"))
(add-hook 'org-mode-hook
          (lambda ()
            (visual-line-mode)
            (flyspell-mode)
            (auto-fill-mode -1)))
#+END_SRC


*** Org-babel 
#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
(setq org-hide-leading-stars t)       ; remove leading stars in org-mode
(setq org-src-tab-acts-natively t)
(setq org-edit-src-content-indentation 0)
(setq org-fontify-whole-heading-line t)
(defun org-font-lock-ensure ()  ; This is apparently a bugfix. (?)
  (font-lock-fontify-buffer))

(setq org-bullets-bullet-list '("◉" "○")) ; make bullets prettier
(setq org-bullets 1)                  ; activate said pretty bullets

#+END_SRC

** Visual-line-mode

   Make it easy to set margin on visual-line-mode regardless of frame
   size.

#+BEGIN_SRC emacs-lisp
(defvar visual-wrap-column nil)
(defun set-visual-wrap-column (new-wrap-column &optional buffer)
  "Force visual line wrap at NEW-WRAP-COLUMN in BUFFER (defaults
    to current buffer) by setting the right-hand margin on every
    window that displays BUFFER.  A value of NIL or 0 for
    NEW-WRAP-COLUMN disables this behavior."
  (interactive (list (read-number "New visual wrap column, 0 to disable: " (or visual-wrap-column fill-column 0))))
  (if (and (numberp new-wrap-column)
           (zerop new-wrap-column))
      (setq new-wrap-column nil))
  (with-current-buffer (or buffer (current-buffer))
    (visual-line-mode t)
    (set (make-local-variable 'visual-wrap-column) new-wrap-column)
    (add-hook 'window-configuration-change-hook 'update-visual-wrap-column nil t)
    (let ((windows (get-buffer-window-list)))
      (while windows
        (when (window-live-p (car windows))
          (with-selected-window (car windows)
            (update-visual-wrap-column)))
        (setq windows (cdr windows))))))
(defun update-visual-wrap-column ()
  (if (not visual-wrap-column)
      (set-window-margins nil nil)
    (let* ((current-margins (window-margins))
           (right-margin (or (cdr current-margins) 0))
           (current-width (window-width))
           (current-available (+ current-width right-margin)))
      (if (<= current-available visual-wrap-column)
          (set-window-margins nil (car current-margins))
        (set-window-margins nil (car current-margins)
                            (- current-available visual-wrap-column))))))
#+END_SRC

** Flyspell-mode
#+BEGIN_SRC emacs-lisp
(setq ispell-program-name "aspell")
(setq flyspell-mark-duplications-flag nil)
(setq flyspell-consider-dash-as-word-delimiter-flag t)
#+END_SRC
** Comint-mode
#+BEGIN_SRC emacs-lisp
(ansi-color-for-comint-mode-on)         ; interpret and use ansi color codes in shell output windows
(custom-set-variables
 '(comint-scroll-to-bottom-on-input t)  ; always insert at the bottom
 '(comint-scroll-to-bottom-on-output t) ; always add output at the bottom
 '(comint-scroll-show-maximum-output t) ; scroll to show max possible output
 '(comint-completion-autolist t)        ; show completion list when ambiguous
 '(comint-input-ignoredups t)           ; no duplicates in command history
 '(comint-completion-addsuffix t)       ; insert space/slash after file completion
 )

#+END_SRC
** Icomplete-mode   
   Icomplete attempts to complete any command which prompts for a list
   of choices.
#+BEGIN_SRC emacs-lisp
(icomplete-mode 1)
#+END_SRC
** Ido-mode

   Ido helps with the find-file and switch-to-buffer prompts (will
   override icomplete for these functions)

#+BEGIN_SRC emacs-lisp
(ido-mode 1)
;; (if (version< emacs-version "25") ; make separator a newl
;;     (progn
;;       (make-local-variable 'ido-separator)
;;       (setq ido-separator "\n"))
;;   (progn
;;     (make-local-variable 'ido-decorations)
;;     (setf (nth 2 ido-decorations) "\n")))

(setq ido-enable-flex-matching t) ; match substrings
(setq ido-default-file-method     ; open file in current window
      'selected-window)                   
(setq ido-default-buffer-method   ; open buffer in current window
      'selected-window)                   
(setq max-mini-window-height 0.5) ; allow ido to show alternatives
                                  ; vertically
#+END_SRC

** DNS-mode

   A decade or so ago, I manually edited dns zone files a lot, and I
   made frequent use of the $INCLUDE directive - meaning most dns zone
   files didn't have a SOA post to increment. This resulted in an
   error when saving. 

   I wrote this piece of advice to avoid this problem.

#+BEGIN_SRC emacs-lisp
(defadvice dns-mode-soa-maybe-increment-serial (before maybe-set-increment)
  "if there is a dns soa post, increment it. Otherwise, just save"
  (save-excursion
    (beginning-of-buffer)
    (message "dns-mode-soa-auto-increment-serial %s"
             (setq dns-mode-soa-auto-increment-serial
                   (and (search-forward-regexp "IN[ ''\t'']+SOA" nil t)
                        (not (search-forward-regexp "@SERIAL@" nil t)))
                   )
             )
    )
  )

(ad-activate 'dns-mode-soa-maybe-increment-serial)
#+END_SRC

** Ibuffer-mode

   A nice list-buffer replacement.

#+BEGIN_SRC emacs-lisp
(require 'ibuffer)

(setq ibuffer-saved-filter-groups
      (quote (("default"
               ("Org" ;; all org-related buffers
                (mode . org-mode))
;;               ("Recruitment"
;;                (filename . "candidates"))
               ("Remote machines"
                (name . "^\\*tramp"))
               ("Personal WC"
                (filename . "wc/"))
;;               ("Erc"
;;                (mode . erc-mode))
               ("Mail"
                (or  ;; mail-related buffers
                 (mode . message-mode)
                 (mode . mail-mode)
                 (mode . mutt-mode)
                 ))
               ("Version Control" (or (mode . svn-status-mode)
                                      (mode . svn-log-edit-mode)
                                      (name . "^\\*svn-")
                                      (name . "^\\*vc\\*$")
                                      (name . "^\\*Annotate")
                                      (name . "^\\*git-")
                                      (name . "^\\*vc-")))
               ("Emacs lisp"
                (mode . emacs-lisp-mode))
               ("Emacs auto"
                (or (name . "^\\*scratch\\*$")
                    (name . "^\\*Messages\\*$")
                    (name . "^\\*Help\\*$")
                    (name . "^\\*info\\*$")
                    (name . "^\\*Occur\\*$")
                    (name . "^\\*grep\\*$")
                    (name . "^\\*Compile-Log\\*$")
                    (name . "^\\*Backtrace\\*$")
                    (name . "^\\*Process List\\*$")
                    (name . "^\\*gud\\*$")
                    (name . "^\\*Man")
                    (name . "^\\*Kill Ring\\*$")
                    (name . "^\\*Calendar\\*$")
                    (name . "^\\*Completions\\*$")
                    (name . "^\\*shell\\*$")
                    (name . "^\\*compilation\\*$")))
               )
              )
             )
      )

(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-switch-to-saved-filter-groups "default")))
(setq ibuffer-default-sorting-mode 'major-mode)
#+END_SRC
** Erc-mode

   I don't use IRC as much nowadays, but used this config when I did.
#+BEGIN_SRC emacs-lisp
;; set a max-size to a irc buffer...
(setq erc-max-buffer-size 20000)

;; Make erc prompt show channelname.
(setq erc-prompt
      (lambda ()
        (if (and (boundp 'erc-default-recipients) (erc-default-target))
            (erc-propertize (concat (erc-default-target) ">")
                            'read-only t 'rear-nonsticky t 'front-nonsticky t)
          (erc-propertize (concat "ERC>")
                          'read-only t 'rear-nonsticky t 'front-nonsticky t))))

(defun start-irc ()
  "Connect to IRC."
  (interactive)
  (require 'erc)
  (erc-ssl
   :server me/erc/server
   :port me/erc/port
   :nick me/erc/nick
   :password me/erc/pass ; (read-passwd me/erc/pass-query-string)
   :full-name me/fullname)
  (setq erc-autojoin-channels-alist me/erc/autojoin-alist)
)


#+END_SRC
** Longlines-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'longlines-mode-hook
          (lambda()
            (auto-fill-mode -1)
            (longlines-show-hard-newlines)))
#+END_SRC
** Adoc-mode-hook
   For asciidoc mode
#+BEGIN_SRC emacs-lisp
(add-hook 'adoc-mode-hook
          (lambda()
            (auto-fill-mode -1)
            (visual-line-mode)))
#+END_SRC
** Python-mode
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
          (lambda()
            (cond ((eq buffer-file-number nil)
                   (progn (interactive)
                          (goto-line 1)
                          (insert "#!/usr/bin/env python\n")
                          (insert "# -*- tab-width: 4 -*-\n")
                          )))))

#+END_SRC
** Java-mode
#+BEGIN_SRC emacs-lisp
(defun my-java-mode-hook ()
  (c-add-style
   "my-java"
   '("java"
     (c-basic-offset . 2)))
  (c-set-style "my-java"))
(add-hook 'java-mode-hook 'my-java-mode-hook)
#+END_SRC
** Atomic-chrome
   A nifty tool which enables me to edit text areas in google chrome
   inside of an emacs frame. To get this to work, make sure you
   install [[https://chrome.google.com/webstore/detail/atomic-chrome/lhaoghhllmiaaagaffababmkdllgfcmc][the Atomic-chrome extension]] for Google chrome. Apparently
   there's another extension you could use for firefox too.

#+BEGIN_SRC emacs-lisp
(require 'atomic-chrome)
(atomic-chrome-start-server)
(setq atomic-chrome-buffer-open-style 'frame)
(setq atomic-chrome-extension-type-list '(atomic-chrome))
;;(setq atomic-chrome-default-major-mode 'markdown-mode)
#+END_SRC

** Mail and Mutt mode
*** Basics
    First some settings to get mail to work.

#+BEGIN_SRC emacs-lisp

(require 'smtpmail)
(require 'starttls)

;;(setq smtpmail-auth-credentials '(("smtp.gmail.com" 25 "USERNAME" "PASSWORD")))
;;(setq smtpmail-debug-info t)
(setq message-send-mail-function 'smtpmail-send-it)
(setq send-mail-function 'smtpmail-send-it)
(setq smtpmail-debug-info t)
(setq mail-host-address me/mail/mydomain)
(setq smtpmail-local-domain me/mail/mydomain)
(setq smtpmail-sendto-domain me/mail/mydomain)
(setq smtpmail-smtp-server me/mail/smtp-server)
(setq smtpmail-auth-credentials me/mail/credentials)
(setq smtpmail-smtp-service 587)
(setq smtpmail-warn-about-unknown-extensions t)
(setq starttls-extra-arguments nil)
(setq starttls-use-gnutls t)
(setq user-full-name me/fullname)
(setq mail-default-headers
      (concat
       "CC:\n"
       "BCC:\n"
       "X-RefLink: http://tinyurl.com/bprfeg\n"
       "User-Agent: " (mapconcat 'identity (subseq (split-string (emacs-version) " ") 0 3) " ") "\n"
        ))
(setq mail-signature me/mail/signature)
#+END_SRC

*** Good to know
   Oh and before I forget - when I flub my password, use the following
   to drop all credentials.
#+BEGIN_SRC 
   M-x auth-source-forget-all-cached
#+END_SRC

*** Mail hook
   A hook to set things up nicely for mutt.

#+BEGIN_SRC emacs-lisp
(defun my-mutt-mode-hook ()
  (visual-line-mode)
  (orgstruct-mode)
  )
(add-hook 'message-mode-hook 'my-mutt-mode-hook)

(add-hook 'mail-mode-hook
          '(lambda ()
             (define-key mail-mode-map "\C-c\C-w" 'message-replace-sig)
             ))
#+END_SRC

** Hooks with no particular home
   Finally, a bunch of small hooks for various modes.

#+BEGIN_SRC emacs-lisp
(add-hook 'css-mode-hook 'hexcolour-add-to-font-lock)
(add-hook 'html-helper-mode-hook 'hexcolour-add-to-font-lock)
(add-hook 'html-mode-hook 'hexcolour-add-to-font-lock)
(add-hook 'html-mode-hook 'set-html-mode-end-paragraph)
(add-hook 'text-mode-hook 'visual-line-mode)
#+END_SRC

* Interactive functions

  Here's a bunch of functions, some of them written by me, most by
  other people.

** Set frame title bar

   Create a reasonable titlebar for emacs, which works on both windows
   and unix. Note: assumes HOSTNAME is exported.

#+BEGIN_SRC emacs-lisp

(defun create_title_format (user host)
  "Creates a window title string which works for both win and unix"
  (interactive)
  (list (getenv user) "@" (getenv host) ":"
        '(:eval
          (if buffer-file-name
              (replace-regexp-in-string
               home
               "~"
               (buffer-file-name))
            (buffer-name))))
  )

;; Set window and icon title.
(if (eq system-type 'windows-nt)
    (setq frame-title-format (create_title_format "USERNAME" "COMPUTERNAME"))
  (setq frame-title-format (create_title_format "USER" "HOSTNAME")))
#+END_SRC

** Buffer navigation functions
#+BEGIN_SRC emacs-lisp

(defun switch-to-scratch ()
  "Switch to scratch buffer. Create one in `emacs-lisp-mode' if not exists."
  (interactive)
  (let ((previous (get-buffer "*scratch*")))
    (switch-to-buffer "*scratch*")
    ;; don't change current mode
    (unless previous (emacs-lisp-mode))))

(defun open-dot-emacs ()
  "Opens my main emacs configuration file."
  (interactive)
  (find-file emacs-root)
  (search-forward (concat (file-name-base this-file-org) (file-name-extension this-file-org t)))
  )

#+END_SRC

** DNS-related functions

   generate-ptr-records and sort-A-records were really useful for me
   back when I managed Spotify's DNS manually in the bad-old-days.

#+BEGIN_SRC emacs-lisp

(defun generate-ptr-records (start-pos end-pos)
  "Finds DNS A-records in region, and for each one, creates a PTR
record in a temporary buffer.

The PTR posts are sorted into sections by domainname.

If no region was set, finds all A-records from point to end of buffer."

  (interactive "r")
  (let (origin            ; to make the hostname a fqdn
        rgx               ; ugly regex matching an A-record

        hostname          ; one hostname
        ip                ; one IPv4 address
        oct-list          ; each IPv4 octet in a list
        first-octets      ; 'aaa.bbb.ccc'
        last-octet        ; 'ddd'
        comment           ; optional comment, if any

        ptr-rec           ; one generated PTR record
        list-of-ptr-recs  ; PTR records with first 3 octets in common
        ptr-hash          ; key first 3 octets, value list-of-ptr-recs
        )


    ;; if no region was set, work from point to end-of-buffer.
    (setq end-pos (if (= (point) (mark)) (end-of-buffer)))

    ;; Bring point to beginning of region if selection was made from
    ;; upper part of the buffer to the end.
    (if (> (point) (mark)) (exchange-point-and-mark))

    ;; Pads string to three chars
    (defun pad-octet (octet)
      (if (= (length octet) 3)
          octet
        (pad-octet (concat octet " "))))


    ;; Read Origin from minibuffer
    (setq origin
          (read-from-minibuffer
           "Enter $ORIGIN: "
           (chomp (shell-command-to-string (concat "hostname -d")))))
    (setq origin (if (string= (substring origin -1) ".") ; make fqdn
                     origin                              ; if not fqdn
                   (concat origin ".")))

    ;; Regexp matching an A-record with optional comment
    (setq rgx
          (concat
           ;; hostname part
           "^\\([[:alnum:]\.-]+\\)"
           ".*?"

           ;; followed by A
           "[ ''\t'']A[ ''\t'']+"
           ".*?"

           ;; followed by (very) loose definition of an ip address
           "\\([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\\)"

           ;; followed by an optional comment
           ".*?\\(;.*?\\)?$"))

    ;; Walk through region, picking up all A-records and putting them
    ;; into a hash, using first three octets as key
    (setq ptr-hash (make-hash-table :test 'equal))
    (while (search-forward-regexp rgx end-pos 1)
      (setq hostname (match-string 1))
      (setq ip (match-string 2))
      (setq comment (if (null (match-string 3)) "" (match-string 3)))

      (setq oct-list (split-string ip "\\."))
      (setq first-octets (mapconcat
                          (lambda (x) x)
                          (nreverse (cons "IN-ADDR.ARPA." (butlast oct-list 1)))
                          "."))
      (setq last-octet (nth 3 oct-list))

      ;; create a PTR record
      (setq ptr-rec (concat (pad-octet last-octet)
                            "  IN  PTR  "
                            hostname "." origin
                            " " comment))

      ;; put the PTR record into the correct list
      (setq list-of-ptr-recs (gethash first-octets ptr-hash))
      (setq list-of-ptr-recs
            (if (null list-of-ptr-recs)
                (list ptr-rec)
              (cons ptr-rec list-of-ptr-recs)))

      ;; put the list
      (puthash first-octets list-of-ptr-recs ptr-hash)
      )

    (with-output-to-temp-buffer "ptr-records"
      (maphash
       (lambda (k v)
         (princ (format "\n$ORIGIN %s\n" k))
         (setq v (sort v (lambda (a b)
                           (< (string-to-number (car (split-string a " ")))
                              (string-to-number (car (split-string b " ")))))))
         (while (not (null v))
           (princ (format "%s\n" (pop v)))
           )
         )
       ptr-hash)
      )
    )
  )

(defun sort-A-records (start-pos end-pos)
  "Given a DNS buffer containing a bunch of A-records, this
function finds all records inside a region and sorts them by ip
address. The output is placed in a temporary buffer called
'sorted-ips'.

Todo someday: support the GENERATE directive"
  (interactive "r")

  ;; --------------------------------------------------
  ;; Helper functions
  (defun eq-octet (a b index)
    (= (string-to-number (nth index a))
       (string-to-number (nth index b))))

  (defun lt-octet (a b index)
    (< (string-to-number (nth index a))
       (string-to-number (nth index b))))


  (defun sort-hash-by-ip (hashtable)
    (let (mylist)
      (setq mylist         ;; Create a list of ip-hostname pairs
            (let (mylist)
              (maphash
               (lambda (kk vv)
                 (setq mylist (cons (list kk vv) mylist))) hashtable)
              mylist
              ))
      (sort mylist         ;; sort them by ip
            (lambda (y z)
              (setq y (split-string  (car y) "\\."))
              (setq z (split-string  (car z) "\\."))

              (if (eq-octet y z 0)
                  (if (eq-octet y z 1)
                      (if (eq-octet y z 2)
                          (lt-octet y z 3)
                        (lt-octet y z 2))
                    (lt-octet y z 1))
                (lt-octet y z 0))
              )
            )
      )
    )



  ;; --------------------------------------------------
  ;; Main body starts here
  (let (iphash)
    ;; create hash
    (setq iphash (make-hash-table :test 'equal))

    ;; if no region selected, just grab all A-records from point.
    (setq end-pos (if (= (point) (mark)) (end-of-buffer)))
    (if (> (point) (mark)) (exchange-point-and-mark))

    (while (search-forward-regexp
            "^\\([[:alnum:]\.-]+\\).*?[ ''\t'']A[ ''\t'']+.*?\\([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+\\)" end-pos 1)
      (puthash (match-string 2) (match-string 1) iphash)
      )

    (with-output-to-temp-buffer "sorted-ips"
      (let (item mylist)
        (setq mylist (sort-hash-by-ip iphash))
        (while (setq item (pop mylist))
          (princ (format "%s\t%s\n" (car item) (cadr item)))
          )
        )
      )
    )
  )


#+END_SRC

** Mail helper functions
#+BEGIN_SRC emacs-lisp

(defun random-quote ()
  "Gets a random quote"
  (load "fimblo-quotes" nil t)
  (aref fimblo-quotes 
        (random (- (length fimblo-quotes) 1)))
  )

(defun generate-sig ()
 (with-temp-buffer
   (insert (random-quote))
   (goto-char (point-min))
   (fill-paragraph)
   (insert (concat
            mail-signature
            "\n\n"))
   (goto-char (point-min))
;;   (while (re-search-forward "^" nil t) (replace-match "  "))
;;   (goto-char (point-min))
;;   (insert "\n-- \n")
   (buffer-string)
   )
 )


(defun kill-signature ()
  "Delete current sig"
  (interactive)
  (end-of-buffer)
  (if (search-backward-regexp "^-- $" nil t )
      (progn
        (beginning-of-line)
        (setq start (point))
        (end-of-buffer)
        (delete-region start (point))))
)

(defun message-replace-sig ()
  "Replaces signature with new sig"
  (interactive)
  (kill-signature)
  (end-of-buffer)
  (delete-char -1)
  (insert (generate-sig))
  )


(defun kill-to-signature ()
  "Delete all text between text and signature."
  (interactive)
  (setq start (point))
  (end-of-buffer)
  (search-backward-regexp "^-- $" nil 1)
  (previous-line)
  (setq end (point))
  (delete-region start end)
  (recenter-top-bottom)
  (insert "\n\n\n")
  (previous-line 2)
  )


(defun mail-snip (b e summ)
  "remove selected lines, and replace it with [snip:summary (n lines)]"
  (interactive "r\nsSummary: ")
  (let ((n (count-lines b e)))
    (delete-region b e)
    (insert (format "\n[snip%s (%d line%s)]\n\n"
                    (if (= 0 (length summ)) "" (concat ": " summ))
                    n
                    (if (= 1 n) "" "s")))))
#+END_SRC

** Simple text manipulation
#+BEGIN_SRC emacs-lisp

(defun merge-lines ()
  "Make paragraph I am in right now into one line."
  (interactive)
  (let (p)
    (forward-paragraph)
    (setq p (point))
    (backward-paragraph)
    (next-line)
    (while (re-search-forward "\n +"  p t)
      (replace-match " ")
      )
    )
)
;; inserts a separator
(fset 'add_separator
      [?\C-a return up ?\C-5 ?\C-0 ?- ?\C-  ?\C-a ?\M-x ?c ?o ?m ?m ?e ?n ?t ?  ?r ?e ?g ?i ?o ?n return down])


(defun insert-time ()
  "Insert date/time at point"
  (interactive)
  (insert (format-time-string "%Y/%m/%d-%R")))


(defun insert-date ()
  "Insert date at point"
  (interactive)
  (insert (format-time-string "%Y%m%d")))


(defun iwb ()
  "indent whole buffer"
  (interactive)
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max) nil)
  (untabify (point-min) (point-max)))


(defun wrap-text (start end)
  "Asks for two strings, which will be placed before and after a
   selected region"
  (interactive "r")
  (let (prefix suffix)
    (setq prefix (read-from-minibuffer "Prefix: "))
    (setq suffix (read-from-minibuffer "Suffix: "))
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (insert prefix)
      (goto-char (point-max))
      (insert suffix)
      )))
(defun wrap-region (start end)
  "Given a prefix and a suffix, this function will wrap each line
in the region such that they are prefixed with the prefix and
suffixed with the suffix.

If no region is selected, it will do the above for all lines from
point to the end of the buffer."


  (interactive "r")
  (let (prefix suffix linecount str-len end-pos)
    (setq prefix (read-from-minibuffer "Prefix: "))
    (setq suffix (read-from-minibuffer "Suffix: "))

    ;; if no region was set, work from point to end-of-buffer.
    (setq end-pos (if (= (point) (mark)) (end-of-buffer) end))

    ;; Bring point to beginning of region if selection was made from
    ;; upper part of the buffer to the end.
    (if (> (point) (mark)) (exchange-point-and-mark))


    (setq linecount (count-lines (point) end-pos))
    (setq linecount (if (= start (point)) 
                        linecount
                      (progn
                        (forward-line)
                        (- linecount 1))))


    (setq str-len (+ end-pos (* linecount  (+ (length (concat prefix suffix))))))

    (message "Start: %s, End-Pos: %s, Point: %s" start end-pos (point))
    (message "Linecount: %s" linecount)

    (while (re-search-forward "^\\(.*\\)$"  str-len  nil)
      (replace-match (concat prefix "\\1" suffix) nil nil)
      )
    )
  )

#+END_SRC
** HTML stuff
#+BEGIN_SRC emacs-lisp
(defun html-mode-end-paragraph ()
  "End the paragraph nicely"
  (interactive)
  (insert "</p>\n"))

(defun hexcolour-luminance (color)
  "Calculate the luminance of a color string (e.g. \"#ffaa00\", \"blue\").
  This is 0.3 red + 0.59 green + 0.11 blue and always between 0 and 255."
  (let* ((values (x-color-values color))
         (r (car values))
         (g (cadr values))
         (b (caddr values)))
    (floor (+ (* .3 r) (* .59 g) (* .11 b)) 256)))

(defun hexcolour-add-to-font-lock ()
  (interactive)
  (font-lock-add-keywords
   nil
   `((,(concat "#[0-9a-fA-F]\\{3\\}[0-9a-fA-F]\\{3\\}?\\|"
               (regexp-opt (x-defined-colors) 'words))
      (0 (let ((colour (match-string-no-properties 0)))
           (put-text-property
            (match-beginning 0) (match-end 0)
            'face `((:foreground ,(if (> 128.0 (hexcolour-luminance colour))
                                      "white" "black"))
                    (:background ,colour)))))))))

#+END_SRC
** Org functions

   For a couple of years I put all my todos into an org-file called
   ~/todo.org. These functions helped me with this.

#+BEGIN_SRC emacs-lisp

(defun switch-to-todo ()
  "Switch to todo buffer. Open file if necessary"
  (interactive)
  (find-file-other-window (concat home "/todo.org"))
  (goto-char (point-min)))


(defun add-todo ()
  "Add a todo to the todo buffer."
  (interactive)
  (add-todo-helper (read-from-minibuffer "Todo: "))
)

(defun add-todo-helper (msg)
  (save-current-buffer
    (set-buffer (find-file-noselect (concat home "/todo.org")))
    (goto-char (point-min))
    (re-search-forward "^\* Todo$" nil t)
    (insert "\n** TODO " msg)
    (org-schedule nil (current-time))
    (save-buffer)
    )
)
#+END_SRC

   I use this following function when I use plain org-mode for
   presentations.
#+BEGIN_SRC emacs-lisp
;; http://stackoverflow.com/questions/12915528/easier-outline-navigation-in-emacs
(defun org-show-next-heading-tidily ()
  "Show next entry, keeping other entries closed."
  (interactive)
  (if (save-excursion (end-of-line) (outline-invisible-p))
      (progn (org-show-entry) (show-children))
    (outline-next-heading)
    (unless (and (bolp) (org-on-heading-p))
      (org-up-heading-safe)
      (hide-subtree)
      (error "Boundary reached"))
    (org-overview)
    (org-reveal t)
    (org-show-entry)
    (show-children)))
#+END_SRC

** Other functions
#+BEGIN_SRC emacs-lisp

(defun toggle-selective-display ()
  "Run this to show only function names in source. run again to go back."
  (interactive)
  (set-selective-display (if selective-display nil 1)))


;; Starts an ansi-term
(defun my-ansi-term()
  "Starts an ansi-term with optional buffer name"

  (interactive)
  (let (string)
    (setq string
          (read-from-minibuffer
           "Enter terminal buffer name: "
           "ansi-term"))
    (ansi-term "/bin/bash" string)
    )
  )


(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))


;; Rename both file and buffer.
;; Ripped from Steve Yegges .emacs
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file name new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))

;; copied from http://blog.tuxicity.se/
;; was called delete-this-buffer-and-file()
(defun delete-file-and-buffer ()
  "Deletes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

;; vi-style parenthesis matching
(defun match-paren (arg)
  "Go to the matching paren if on a paren; otherwise insert %."
  (interactive "p")
  (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
        ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
        (t (self-insert-command (or arg 1)))))


(defun philles-takM-formatterare ()
  "Tar bort dessa irriterande ^M."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (search-forward "" nil t)
      (replace-match "" nil t)))
  )

(defun philles-whitespace-formatterare ()
  "Ta bort allt whitespace (space + tabbar) i slutet av varje rad i bufferten"
  (interactive)
  (message "Function disabled. Use delete-trailing-whitespace instead.")
  )

;; Never compile .emacs by hand again
;;(add-hook 'after-save-hook 'autocompile)
;; (defun autocompile ()
;;   "compile itself if dot.emacs.el"
;;   (interactive)
;;   (if (string= (buffer-file-name) (concat default-directory "dot.emacs.el"))
;;       (byte-compile-file (buffer-file-name))))




#+END_SRC

* Helper functions
#+BEGIN_SRC emacs-lisp

(defun insert-fat-comma () 
  "Inserts a ' => ' at point.

   Used in Perl and Javascript."
  (interactive)
  (insert " => ")
)

(defun file-string (file)
    "Read the contents of a file and return as a string."
    (with-temp-buffer
      (insert-file-contents file)
      (buffer-string)))

(defun chomp (str)
  "Chomp tailing newlines from string"
  (let ((s (if (symbolp str) (symbol-name str) str)))
    (replace-regexp-in-string "[''\n'']*$" "" s)))

(defun get-ipv4-regex ()
  (let (p1 p2 p3 octet-re)
    (setq p1 "[01]?[[:digit:]]?[[:digit:]]")
    (setq p2 "2[01234][[:digit:]]")
    (setq p3 "25[012345]")
    (setq octet-re (concat "\\(" p1 "\\|" p2 "\\|" p3 "\\)"))
    (concat "^" (mapconcat (lambda (x) x)
                           (list octet-re octet-re octet-re octet-re)
                           "\\.") "$")
    )
  )

#+END_SRC
* Keybindings
** Mode-specific keybindings
#+BEGIN_SRC emacs-lisp
(eval-after-load 'message
  '(define-key message-mode-map [ f9 ] 'message-replace-sig))
(eval-after-load 'message
  '(define-key message-mode-map [?\C-c ?\C-k] 'kill-to-signature))

(add-hook 'cperl-mode-hook
          (lambda ()
            (local-set-key (kbd "M-,") 'insert-fat-comma)))
(add-hook 'js-mode-hook
          (lambda ()
            (local-set-key (kbd "M-,") 'insert-fat-comma)))



;; make this org-specific later
;; (global-set-key [ f10 ]   'org-show-next-heading-tidily)


#+END_SRC

** Global keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key "\C-x\C-g"          'find-file-at-point)
(global-set-key "\C-x\C-m"          'execute-extended-command)
(global-set-key "\C-c\C-m"          'execute-extended-command)
(global-set-key "\C-c\C-g"          'goto-line)
(global-set-key "\C-c\C-k"          'kill-buffer)
(global-set-key "\C-cc"             'compile)
(global-set-key "\C-co"             'org-capture)
(global-set-key "\C-cd"             'gdb)
(global-set-key "\C-cn"             'next-error)
(global-set-key "\C-c\C-d"          'insert-date)
(global-set-key "\C-xm"             'mail)
(global-set-key (kbd "M-0")         'add_separator)
(global-set-key [ \C-tab ]          'hippie-expand)
;(global-set-key [ f35 ]             'delete-char)
(global-set-key [ f5 ]              'switch-to-scratch)
(global-set-key [ M-f5 ]            'open-dot-emacs)
;(global-set-key [ f6 ]              'toggle-selective-display)
;(global-set-key [ f6 ]              'switch-to-todo)
;(global-set-key [ S-f6 ]            'add-todo)
(global-set-key [ f7 ]              'my-ansi-term)
(global-set-key [ f8 ]              'hl-line-mode)
(global-set-key [ M-f8 ]            'linum-mode)
(global-set-key [ f11 ]             '(lambda () (interactive) (enlarge-window 4 )))
(global-set-key [ M-f11 ]           '(lambda () (interactive) (enlarge-window -4)))
(global-set-key [ f12 ]             '(lambda () (interactive) (enlarge-window 4 1)))
(global-set-key [ M-f12 ]           '(lambda () (interactive) (enlarge-window -4 1)))
(global-set-key [ home ]            'beginning-of-buffer)
(global-set-key [ end ]             'end-of-buffer )
(global-set-key "\C-x\C-y"          'toggle-truncate-lines)
(global-set-key (kbd "C-x <down>")  'windmove-down)
(global-set-key (kbd "C-x <up>")    'windmove-up)
(global-set-key (kbd "C-x <right>") 'windmove-right)
(global-set-key (kbd "C-x <left>")  'windmove-left)
(global-set-key (kbd "C-x C-b")     'ibuffer)
(global-set-key (kbd "M-%")         'query-replace-regexp)
(global-set-key [(shift down)]      '(lambda () (interactive) (scroll-up 3)))
(global-set-key [(shift up)]        '(lambda () (interactive) (scroll-down 3)))
(global-set-key (kbd "C-x SPC")     'show-ws-toggle-show-trailing-whitespace)
(global-set-key (kbd "C-S-e")       'merge-lines)   
(global-set-key (kbd "C-h C-s")     'find-function-at-point)

#+END_SRC

* lint
#+BEGIN_SRC emacs-lisp

;;(defmacro help/on-gui (statement &rest statements)
;;  "Evaluate the enclosed body only when run on GUI."
;;  `(when (display-graphic-p)
;;     ,statement
;;     ,@statements))

;; or
;;
;;(when (display-graphic-p)
;;  (set-frame-font "...")
;;  (require '...)
;;  (...-mode)) 
;;

#+END_SRC
